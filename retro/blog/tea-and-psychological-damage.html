<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="32 Rounds of TEA and Psychological Damage, Surviving a Stripped 32-bit Binary">
  <title>32 Rounds of TEA and Psychological Damage, Surviving a Stripped 32-bit Binary - ~siddharth~</title>
  <link rel="stylesheet" href="../style.css">
  <style>
    /* Blog specific styles */
    .blog-content { font-family: "Verdana", sans-serif; line-height: 1.6; font-size: 14px; }
    .blog-content h1, .blog-content h2, .blog-content h3 { color: #000080; margin-top: 20px; border-bottom: 1px dotted #ccc; padding-bottom: 5px; }
    .blog-content p { margin-bottom: 15px; }
    .blog-content img { max-width: 100%; border: 1px solid #999; padding: 4px; background: #fff; }
    .blog-content .img-container { text-align: center; margin: 20px 0; }
    .blog-content pre { background: #eee; border: 1px inset #ccc; padding: 10px; overflow-x: auto; font-family: "Courier New", monospace; }
    .blog-content code { background: #f0f0f0; padding: 2px 4px; font-family: "Courier New", monospace; }
    .blog-content blockquote { border-left: 4px solid #000080; padding-left: 10px; color: #555; font-style: italic; margin: 15px 0; }
    .blog-meta { color: #666; font-size: 11px; margin-bottom: 20px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
  </style>
</head>
<body>

<div class="top-banner">
  <marquee behavior="scroll" direction="left" scrollamount="3">
    *** Reading: 32 Rounds of TEA and Psychological Damage, Surviving a Stripped 32-bit Binary *** Post Date: 2025-12-29 ***
  </marquee>
</div>

<table class="main-table" cellpadding="0" cellspacing="0">
  <tr>
    <td class="sidebar" valign="top">
      <div class="sidebar-box">
        <div class="sidebar-title">Navigation</div>
        <ul class="nav-list">
          <li><a href="../index.html">[ Home ]</a></li>
          <li><a href="../about.html">[ About Me ]</a></li>
          <li><a href="../projects.html">[ Projects ]</a></li>
          <li><a href="../blog.html">[ Blog ]</a></li>

        </ul>
      </div>
      
      <div class="sidebar-box">
        <div class="sidebar-title">Actions</div>
        <ul class="nav-list">
          <li><a href="javascript:history.back()">&lt;&lt; Go Back</a></li>
          <li><a href="#">Top of Page</a></li>
        </ul>
      </div>
    </td>

    <td class="content" valign="top">
      <div class="page-header">
        <h1>32 Rounds of TEA and Psychological Damage, Surviving a Stripped 32-bit Binary</h1>
        <hr class="fancy-hr">
      </div>

      <p class="breadcrumb"><a href="../index.html">Home</a> &gt; <a href="../blog.html">Blog</a> &gt; 32 Rounds of TEA and Psychological Damage, Surviving a Stripped 32-bit Binary</p>

      <div class="content-box">
        <div class="blog-meta">
           <strong>Date:</strong> 2025-12-29 | <strong>Tags:</strong> 
        </div>
        
        <div class="blog-content">
          <div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-1.png" alt="Binary Analysis"></div>
<p>
This program is a 32-bit ARM binary. This means it is meant to run on ARM systems and not on regular x86 machines, so it cannot be run directly. The binary is also stripped, meaning there are no useful function names, and it is dynamically linked. Even though it cannot be executed easily, running it is not required. Static analysis is enough to understand the logic and solve the challenge.
</p>
<h2>Initial Analysis</h2>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-2.png" alt="Program Output"></div>
<p>
When the program starts, it prints a message and waits for user input. The input is read using the <code>read()</code> function. Instead of keeping the input as raw text, the program parses it into numbers and stores them contiguously in a heap-allocated buffer. These parsed values are later treated as fake registers for a custom virtual machine implemented by the binary.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-3.png" alt="Input Parsing"></div>
<h2>The Virtual Machine</h2>
<p>
After parsing the input, execution jumps into a function named <code>fcn.00008410</code>. This function works as the main VM interpreter. From this point onward, the program is no longer executing normal ARM instructions. Instead, it starts reading and executing VM bytecode stored as data inside the binary.
</p>
<p>
Each VM instruction is 4 bytes long. The first byte is the opcode, which decides what operation to perform. The remaining three bytes are arguments. The opcode is used as an index into a jump table, which then jumps to the corresponding instruction handler.
</p>
<p>
The VM maintains its own execution state similar to a real CPU. It has its own registers, its own stack, and its own instruction pointer. Register index 30 is used as the stack pointer, while register index 31 stores the current VM instruction pointer.
</p>
<h2>Reverse Engineering the Instruction Set</h2>
<p>
By analyzing where the jump table leads and observing what each handler does, the VM instruction set can be identified. As the purpose of each handler becomes clear, they are renamed in radare2 to match their behavior. For example, one instruction was identified as a load lower immediate and renamed <code>LLi</code>.
</p>
<h3>Load Lower Immediate (LLi)</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-4.png" alt="Load Lower Immediate"></div>
<p>
This instruction loads an immediate value into the lower portion of a register.
</p>
<h3>Load Upper Immediate (LUi)</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-5.png" alt="Load Upper Immediate"></div>
<p>
Another similar instruction was identified as Load Upper Immediate, which loads an immediate value into the upper portion of a register.
</p>
<h3>Addition (vm_add)</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-6.png" alt="Addition Operation"></div>
<p>
The next instruction handled addition between values.
</p>
<h3>Conditional Jump</h3>
<p>
The next instruction was particularly complex. It combines two bytes into a 16-bit value and then performs conditional logic based on comparisons. It checks whether a condition is met and updates the VM instruction pointer accordingly. Based on its behavior, this instruction appears to act like a conditional jump.
</p>
<h3>Compare Instruction</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-7.png" alt="Compare Instruction"></div>
<p>
After that, another instruction was identified which performs comparisons between values.
</p>
<h3>Stack Operations</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-8.png" alt="Push Operation"></div>
<p>
Two instructions handle stack management:
- <strong>Push</strong>: Pushes values onto the VM stack
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-9.png" alt="Pop Operation"></div>
<p>
- <strong>Pop</strong>: Pops values from the VM stack
</p>
<h3>Subtraction (vm_sub)</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-10.png" alt="Subtraction Operation"></div>
<p>
Another instruction performs subtraction between values.
</p>
<h3>Bit Shifting</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-11.png" alt="Bit Shifting"></div>
<p>
This instruction was more math-heavy and performs bit shifting operations before producing a result.
</p>
<h3>XOR Operation</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-12.png" alt="XOR Operation"></div>
<p>
The next instruction performs an XOR operation.
</p>
<h3>NOP</h3>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-13.png" alt="NOP Instruction"></div>
<p>
Finally, this instruction does nothing and serves as a NOP.
</p>
<h2>The Opcode Table</h2>
<p>
After finally renaming all the VM instructions in radare2, I ended up with a clear structure of how the virtual machine works internally.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-14.png" alt="VM Structure"></div>
<p>
I also identified the main VM dispatcher, which is responsible for fetching each instruction, decoding the opcode, and jumping to the correct handler.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-15.png" alt="VM Dispatcher"></div>
<p>
Since the opcode handlers were already renamed and understood, I mapped out the full opcode table.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-16.png" alt="Opcode Table"></div>
<p>
With this information, the extracted VM bytecode could now be mapped properly, because we know what each register represents and what each instruction does.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-17.png" alt="Bytecode Dump"></div>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-20.png" alt="Keygen"></div>
<h2>Discovering TEA Encryption</h2>
<p>
At this point, the next goal was figuring out how to convert this raw bytecode dump into readable pseudocode.
</p>
<p>
When the VM starts running, it first loads two constant values. One of them is <code>0x9e3779b9</code>, which is a well-known constant used in the TEA (Tiny Encryption Algorithm) encryption algorithm. This immediately hints that some kind of encryption or mixing logic is involved.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-18.png" alt="TEA Constant"></div>
<h2>The Algorithm</h2>
<p>
Instead of explaining everything line by line, the image below gives a clean high-level view of what the VM is actually doing.
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-19.png" alt="Algorithm Overview"></div>
<p>
In short, the program takes your input key and scrambles it using a small encryption-like routine that runs for 32 rounds. After all rounds are done, the final result is compared against two hardcoded secret values. If the values match, the key is accepted.
</p>
<h2>Keygen Solution</h2>
<p>
To solve this, I wrote a keygen in Rust that reverses the TEA encryption process:
</p>
<pre class="code-block"><code>use rand::Rng;

fn combine(seed: u32, a: u32, b: u32, c: u32) -&gt; u32 {
    let r9  = a.wrapping_shr(5).wrapping_add(b);
    let r10 = a.wrapping_add(seed);
    let r11 = a.wrapping_shl(4).wrapping_add(c);
    r11 ^ r10 ^ r9
}

fn validate(mut serial: [u32; 6]) -&gt; bool {
    let mut r6 = 0xc6ef_3720u32;
    let r7 = 0x9e37_79b9u32;

    for _ in 0..32 {
        let r12 = combine(r6, serial[0], serial[5], serial[4]);
        serial[1] = serial[1].wrapping_sub(r12);

        let r12 = combine(r6, serial[1], serial[3], serial[2]);
        serial[0] = serial[0].wrapping_sub(r12);

        r6 = r6.wrapping_sub(r7);
    }

    serial[0] == 0xba01_aafe &amp;&amp; serial[1] == 0xbbff_31a3
}

fn keygen() -&gt; [u32; 6] {
    let mut serial = [0u32; 6];

    serial[0] = 0xba01_aafe;
    serial[1] = 0xbbff_31a3;

    let mut rng = rand::thread_rng();
    serial[2] = rng.gen::&lt;u32&gt;();
    serial[3] = rng.gen::&lt;u32&gt;();
    serial[4] = rng.gen::&lt;u32&gt;();
    serial[5] = rng.gen::&lt;u32&gt;();

    let mut r6 = 0x9e37_79b9u32;

    for _ in 0..32 {
        let r12 = combine(r6, serial[1], serial[3], serial[2]);
        serial[0] = serial[0].wrapping_add(r12);

        let r12 = combine(r6, serial[0], serial[5], serial[4]);
        serial[1] = serial[1].wrapping_add(r12);

        r6 = r6.wrapping_add(0x9e37_79b9);
    }

    serial
}

fn main() {
    for _ in 0..100 {
        let s = keygen();
        assert!(validate(s));
        println!(
            "{:08x},{:08x},{:08x},{:08x},{:08x},{:08x}",
            s[0], s[1], s[2], s[3], s[4], s[5]
        );
    }
}
</code></pre>
<p>
The keygen generates valid serials by:
1. Starting with the target values (<code>0xba01aafe</code> and <code>0xbbff31a3</code>)
2. Generating random values for the other four registers
3. Running the TEA algorithm forward for 32 rounds
</p>
<div class="img-container"><img src="../images/posts/tea-and-psychological-damage/vm2-21.png" alt="Output"></div>
<p>
4. The resulting values become valid input keys
</p>
<p>
This challenge was a great exercise in reverse engineering a custom virtual machine and understanding classic encryption algorithms!
</p>
        </div>
      </div>

    </td>
  </tr>
</table>

<div class="footer">
  <hr class="fancy-hr">
  <p>&#169; 2026 Siddharth | <a href="../index.html">Back to Home</a></p>
</div>

</body>
</html>
